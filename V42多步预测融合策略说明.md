# V42 多步预测融合策略说明

## 问题背景

在V42滑动窗口LSTM中，模型可以一次性预测未来多个时间步（例如`pred_steps=3`）。当窗口滑动时，同一个时间点可能被多次预测到，产生多个预测值。如何融合这些预测值是一个关键问题。

### 场景示例

假设`window_size=5`, `pred_steps=3`：

```
窗口位置1: [t0, t1, t2, t3, t4] → 预测 [t5, t6, t7]
窗口位置2: [t1, t2, t3, t4, t5] → 预测 [t6, t7, t8]
窗口位置3: [t2, t3, t4, t5, t6] → 预测 [t7, t8, t9]
```

可以看到：
- **t6** 被预测了2次（窗口1和窗口2）
- **t7** 被预测了3次（窗口1、2、3）

如何选择或融合这些预测值？

---

## 两种融合策略

### 1. **jump（跳跃式）**

**原理**: 窗口每次移动`pred_steps`步，避免重叠。

**示例** (`window_size=5`, `pred_steps=3`):
```
窗口1: [t0, t1, t2, t3, t4] → 预测 [t5, t6, t7]
窗口2: [t3, t4, t5, t6, t7] → 预测 [t8, t9, t10]  ← 跳过3步
窗口3: [t6, t7, t8, t9, t10] → 预测 [t11, t12, t13]
```

**特点**:
- ✅ 无重叠，每个时间点只预测一次
- ✅ 计算效率高（预测次数少）
- ✅ 适用于单步和多步预测
- ❌ 无法利用多次预测的信息

**适用场景**: 快速预测、实时系统、单步预测

---

### 2. **weighted（加权平均）** ⭐ 推荐（多步预测）

**原理**: 窗口每次移动1步，对同一时间点的多次预测进行**加权平均**，距离越近权重越大，**关键是权重归一化**。

**权重计算**（关键修正！）:
```python
# 原始权重（距离越近权重越大）
raw_weights[k] = 1 / (k + 1)

# 归一化（使权重和=1）
normalized_weights[k] = raw_weights[k] / sum(raw_weights)
```

**单步预测** (`pred_steps=1`):
```
每个时间点只有1个预测值，归一化权重 = 1.0
结果与jump模式相同
```

**多步预测示例** (`window_size=5`, `pred_steps=3`):
```
t7的预测值:
- 窗口1预测的t7: 7.2（1步预测）
- 窗口2预测的t7: 7.1（2步预测）
- 窗口3预测的t7: 7.0（3步预测）

原始权重:
- w0 = 1/1 = 1.0
- w1 = 1/2 = 0.5
- w2 = 1/3 = 0.33
- 权重和 = 1.83

归一化权重（关键！）:
- w0' = 1.0/1.83 = 0.546
- w1' = 0.5/1.83 = 0.273
- w2' = 0.33/1.83 = 0.180
- 验证: 0.546 + 0.273 + 0.180 ≈ 1.0 ✓

加权平均（修正后）:
= 7.2×0.546 + 7.1×0.273 + 7.0×0.180
= 3.931 + 1.939 + 1.260
= 7.13

错误示范（未归一化）:
= (7.2×1.0 + 7.1×0.5 + 7.0×0.33) / 1.83
= 12.86 / 1.83
= 7.02  ← 数值偏差！
```

**特点**:
- ✅ 充分利用多次预测信息
- ✅ 赋予近期预测更高权重（更可靠）
- ✅ **权重归一化**，避免数值偏差
- ✅ 平滑噪声，提高稳定性
- ⚠️ 单步预测时与jump等价

**适用场景**: **多步预测**（`pred_steps ≥ 2`）时的最佳选择

---

## 理论分析

### 预测误差随距离增长

在时间序列预测中，**预测步数越多，误差越大**：

$$
\sigma_k^2 \approx k \cdot \sigma_1^2
$$

其中 $\sigma_k^2$ 是 $k$ 步预测的方差，$\sigma_1^2$ 是1步预测的方差。

### 加权平均的数学依据

加权平均使用**逆方差加权**的思想：

$$
w_k = \frac{1}{\sigma_k^2} \propto \frac{1}{k}
$$

**归一化**（确保无偏估计）：

$$
w_k' = \frac{w_k}{\sum_{j=1}^{K} w_j}
$$

最终加权平均：

$$
\hat{y}_t = \sum_{k=1}^{K} w_k' \cdot y_{t,k}, \quad \text{where } \sum_{k=1}^{K} w_k' = 1
$$

这使得**误差小的预测**（近期）获得更高权重，同时保证权重和为1，避免数值偏差。

---

## 关键发现：权重归一化的重要性

### ❌ 未归一化的问题

```python
# 错误示例：权重和不为1
weights = [1.0, 0.5, 0.33]  # 和 = 1.83
result = (7.2×1.0 + 7.1×0.5 + 7.0×0.33) / 1.83 = 7.02
```

**问题**: 
- 权重和 ≠ 1 导致加权平均的数值尺度改变
- 多步预测时误差累积严重
- 导致R²变为负值（预测比平均值还差）

### ✅ 归一化后的正确做法

```python
# 正确示例：权重归一化
raw_weights = [1.0, 0.5, 0.33]
normalized = [0.546, 0.273, 0.180]  # 和 = 1.0
result = 7.2×0.546 + 7.1×0.273 + 7.0×0.180 = 7.13
```

**优势**:
- 权重和 = 1，保证无偏估计
- 避免数值尺度变化
- 预测精度显著提升

---

## 模式选择建议

| 预测步数 | 推荐模式 | 原因 |
|---------|---------|------|
| `pred_steps=1` | **jump** | 单步时weighted等价于jump，但jump效率更高 |
| `pred_steps=2~5` | **weighted** | 平衡多次预测，提高稳定性 |
| `pred_steps≥6` | **jump** | 多步预测误差累积严重，weighted优势不明显 |
| 实时系统 | **jump** | 计算效率最高 |
| 追求准确性 | **weighted** (`pred_steps=2~3`) | 综合多次预测信息 |

---

## V42代码实现

在 `train_v42_sliding_window.py` 中，可通过 `PREDICTION_MODE` 参数选择模式：

```python
PREDICTION_MODE = 'weighted'  # 可选: 'jump', 'weighted'
```

**weighted模式的关键代码**:
```python
# 计算归一化权重（关键修正！）
raw_weights = np.array([1.0 / (step + 1) for step in range(pred_steps)])
normalized_weights = raw_weights / np.sum(raw_weights)  # 权重和=1

# 使用归一化权重累积预测
for step_offset in range(pred_steps):
    weight = normalized_weights[step_offset]
    prediction_accumulator[target_pos] += pred_denorm[step_offset] * weight
    prediction_weights[target_pos] += weight

# 最终加权平均
predictions[i] = prediction_accumulator[i] / prediction_weights[i]
```

---

## 窗口滑动示例

### 单步预测 (`pred_steps=1`, `window_size=5`)

```
第1次: [t0,t1,t2,t3,t4] → t5  |  窗口移动1步
第2次: [t1,t2,t3,t4,t5] → t6  |  窗口移动1步
第3次: [t2,t3,t4,t5,t6] → t7  |  窗口移动1步
```

**jump和weighted等价**（每个点只有1个预测值）

### 多步预测 (`pred_steps=3`, `window_size=5`)

**jump模式**:
```
窗口1: [t0,t1,t2,t3,t4] → [t5,t6,t7]    |  移动3步
窗口2: [t3,t4,t5,t6,t7] → [t8,t9,t10]   |  移动3步
```

**weighted模式**:
```
窗口1: [t0,t1,t2,t3,t4] → [t5,t6,t7]    |  移动1步
窗口2: [t1,t2,t3,t4,t5] → [t6,t7,t8]    |  移动1步（t6,t7重叠）
窗口3: [t2,t3,t4,t5,t6] → [t7,t8,t9]    |  移动1步（t7,t8重叠）

t6 = 0.667×(窗口1的t6) + 0.333×(窗口2的t6)  ← 归一化权重
t7 = 0.546×(窗口1的t7) + 0.273×(窗口2的t7) + 0.180×(窗口3的t7)
```

---

## 总结

- **jump**: 简单高效，无重叠，适用于单步和多步预测
- **weighted**: ⭐ **加权平均（权重归一化），推荐用于多步预测**

**关键要点**:
1. **单步预测** (`pred_steps=1`): 两种模式等价，推荐jump（效率高）
2. **多步预测** (`pred_steps≥2`): 推荐weighted（需归一化权重）
3. **权重归一化**是weighted模式的核心，必须确保权重和=1

在V42的超参数网格搜索中，将测试不同`pred_steps`和融合策略的组合，找到最优配置。
